mport java.io.File;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.Random;

public class SortTest {
  
  public static void main(String[] args) {
    // Use args [sortMethod, array size, test array config]
    
    long startTime, stopTime; // For recording start/stop times
    int baseSize = 100000;
    int sortMethod = 0; // QuickSort is default, Insertion Sort = 1
    int testArray = 0; // Default configuration is reverse ordered. Random order = 1
    int tesNum = 0; // To identify test number / modify output file name accordingly
    
    // Set default analysis parameters via passed args
    if (args.length == 0){
      System.out.println("Using all default settings\nAlgorithm = quick sort, test array size = 1e5, test array = reverse");
    }
    
    if (args.length == 1){
      if(args[0] == "insert")
        sortMethod = 1;
    }
    
    if (args.length == 2){
      try{ // Try to set base
        baseSize = Integer.parseInt(args[1]);
      finally {}
      }
    }
    
    if(args.length == 3){
      if(args[2] == "random")
        testArray = 1;
    }
    
    if(args.length == 4){
      
    }
      
    if (args.length > 4)
        System.out.println("Warning: Too many arguments. Ignoring extra inputs.");
    }
    
    // Set up arrays to collect times
    int[] trialSizes = new int[10];
    float[] sortTimes = new float[10]; // Multiple times for each array size
    trialSizes[0] = (int)baseSize;
    
    // Run test case on various-sized arrays
    for (int trial = 0; trial < sortTimes.length; trial++){
      trialSizes[trial] = baseSize*(trial+1); // Fill array of sequence
      
      int maxNum = trialSizes[trial];
      int[] seq = new int[maxNum]; // Initialize the array
      
      // Build various reverse-ordered sequences
      for (int j = 0; j < seq.length; j++){
        seq[j] = maxNum--; // Fill with reverse order        
      }
      
      // Run sort quick sort test on sequence here and collect 5 run-times
      for (int j = 0; j < sortTimes[0].length; j++){
        int[] seq1 = seq.clone();
        if(testArray == 1){
          // Random shuffle matrix
          Random rnd = new Random();
          
        }
        
        startTime = System.currentTimeMillis();
        if (args.length == 2){
          insertionSort(seq1);
        }
        else{ // Use quicksort unless otherwise specified
          quickSort(seq1,0,seq1.length - 1);
        }
        stopTime = System.currentTimeMillis();
      
        sortTimes[trial][j] = (float)(stopTime - startTime);
        if(args.length == 2){
          System.out.print("Insertion Sort ");
        }else{
          System.out.print("Quick Sort ");
        }
        System.out.print("["+trial+", " + j + "]: " + (stopTime - startTime) + "\n");
      }
    }
    
    // Output timing results to file
    File f = null;
    try{
      if(args.length == 2){
        f = new File("sortJavaInsert.csv");
      }else{
        f = new File("sortJavaQuick.csv");
      }
      f.createNewFile();
      
      FileOutputStream fis = new FileOutputStream(f);
      PrintStream out = new PrintStream(fis);
      
      System.out.print("\n");
      
      System.setOut(out);
      
      // First row in each file = sequence length
      for (int j = 0; j < trialSizes.length; j++){
        System.out.print(trialSizes[j]);
        
        if(j < trialSizes.length - 1){
          System.out.print(",");
        }
      }
      
      System.out.print("\n");
      
      // Second row in each file = sorting time
      
      for (int j = 0; j < sortTimes.length; j++){
        System.out.print(sortTimes[j][trial]);
        
        if(j < sortTimes.length - 1){
          System.out.print(",");
        }
      }
      System.out.print("\n");
      
      
      // Close print streams
      out.close();
      
    }catch(Exception e){
    }
  }
}